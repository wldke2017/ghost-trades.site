// ===================================
// AI STRATEGY EXECUTION ENGINE
// ===================================

class AIStrategyRunner {
    constructor() {
        this.isActive = false;
        this.strategyCode = null;
        this.compiledStrategy = null;
        this.runtimeLogs = [];
        this.maxLogs = 50;
        this.executionCount = 0;
        this.lastExecutionTime = 0;
        this.errors = 0;
        this.consecutiveErrors = 0;
        this.allowedMarkets = []; // List of symbols allowed to trade
    }

    /**
     * Compiles the raw code string into an executable function
     * @param {string} code - The function body code
     * @returns {boolean} - Success status
     */
    compile(code) {
        try {
            this.strategyCode = code;
            // Create a function that takes specific safe arguments
            // "use strict" prevents accidental global variable creation
            this.compiledStrategy = new Function('data', 'signal', 'log', '"use strict";\n' + code);
            this.resetStats();
            return true;
        } catch (error) {
            console.error('Compilation Error:', error);
            this.log(`Compilation Error: ${error.message}`, 'error');
            return false;
        }
    }

    /**
     * Start the strategy execution
     * @param {Array<string>} markets - List of selected market symbols (e.g. ['R_100', '1HZ10V'])
     */
    start(markets = []) {
        if (!this.compiledStrategy) {
            this.log('No strategy compiled. Please generate or write code first.', 'error');
            return false;
        }

        if (!markets || markets.length === 0) {
            this.log('No markets selected. Please select at least one market.', 'error');
            return false;
        }

        this.allowedMarkets = markets;
        this.isActive = true;
        this.resetStats();
        this.log(`Strategy execution started on markets: ${markets.join(', ')}`, 'success');
        return true;
    }

    /**
     * Stop the strategy execution
     */
    stop() {
        this.isActive = false;
        this.allowedMarkets = [];
        this.log('Strategy execution stopped.', 'warning');
    }

    resetStats() {
        this.executionCount = 0;
        this.errors = 0;
        this.consecutiveErrors = 0;
    }

    /**
     * Main execution loop called on every tick
     * @param {Object} tickContext - The market data context
     */
    execute(tickContext) {
        if (!this.isActive || !this.compiledStrategy) return;

        // FILTER: Only run for selected markets
        if (!this.allowedMarkets.includes(tickContext.symbol)) {
            return;
        }

        // Rate limit execution to prevent blocking UI (max once per 100ms PER MARKET is hard to track, so we just limit global run loop slightly if needed, but per-tick is better for precision)
        // actually, we should remove the global rate limit if we want to trade multiple markets simultaneously, 
        // OR make it per-symbol.

        // Let's remove the global 100ms throttle because it might skip ticks if multiple markets tick same time.
        // Instead, rely on the fact that JS is single threaded and ticks come sequentially.

        // Prepare safe API functions
        const signal = (type, stake, barrier) => this.handleSignal(type, stake, tickContext.symbol, barrier);
        const log = (msg) => this.log(msg, 'info');

        try {
            // Execute the strategy
            this.compiledStrategy(tickContext, signal, log);
            this.executionCount++;
            this.consecutiveErrors = 0; // Reset consecutive errors on success
        } catch (error) {
            this.errors++;
            this.consecutiveErrors++;
            this.log(`Runtime Error: ${error.message}`, 'error');

            // Safety: Stop if too many consecutive errors
            if (this.consecutiveErrors >= 5) {
                this.stop();
                this.log('Strategy stopped due to 5 consecutive runtime errors.', 'error');
            }
        }
    }

    /**
     * Handles trade signals generated by the strategy
     */
    handleSignal(type, stake, symbol, barrier = null) {
        if (!this.isActive) return;

        // Validate signal
        const validTypes = ['CALL', 'PUT', 'DIGITOVER', 'DIGITUNDER', 'DIGITMATCH', 'DIGITDIFF', 'DIGITEVEN', 'DIGITODD'];
        if (!validTypes.includes(type)) {
            this.log(`Invalid signal type: ${type}`, 'warning');
            return;
        }

        if (isNaN(stake) || stake <= 0) {
            this.log(`Invalid stake: ${stake}`, 'warning');
            return;
        }

        // Rate limiting for trades is handled by app.js usually, but we check basic state
        // Calls the global buy function from trading.js/app.js
        // We assume sendPurchaseRequest or similar exists globally or we dispatch an event

        let logMsg = `Signal Generated: ${type} $${stake} on ${symbol}`;
        if (barrier !== null) logMsg += ` (Barrier: ${barrier})`;
        this.log(logMsg, 'success');

        // Trigger buy in the main app
        if (typeof window.executeAIStratTrade === 'function') {
            window.executeAIStratTrade(type, stake, symbol, barrier);
        } else {
            console.warn('executeAIStratTrade function not found in global scope');
            this.log('Error: Trade execution function missing.', 'error');
        }
    }

    /**
     * internal logger
     */
    log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = { time: timestamp, message, type };

        this.runtimeLogs.push(logEntry);
        if (this.runtimeLogs.length > this.maxLogs) {
            this.runtimeLogs.shift();
        }

        // Update UI if binding exists
        if (typeof window.updateAILogs === 'function') {
            window.updateAILogs(logEntry);
        } else {
            // Fallback console log for debug
            console.log(`[AI Strategy] ${message}`);
        }
    }
}

// Export singleton instance
window.aiStrategyRunner = new AIStrategyRunner();
